[{"title":"analogCalibrate","href":"#analogCalibrate","content":"\n```\r\nint analogCalibrate ( unsigned char  channel )\r\n```\r\nCalibrates the analog sensor on the specified channel.\r\n\r\nThis method assumes that the true sensor value is not actively changing at this time and computes an average from approximately 500 samples, 1 ms apart, for a 0.5 s period of calibration. The average value thus calculated is returned and stored for later calls to the analogReadCalibrated() and analogReadCalibratedHR() functions. These functions will return the difference between this value and the current sensor value when called.\r\n\r\nDo not use this function in initializeIO(), or when the sensor value might be unstable (gyro rotation, accelerometer movement).\r\n\r\nThis function may not work properly if the VEX Cortex is tethered to a PC using the orange USB A to A cable and has no VEX 7.2V Battery connected and powered on, as the VEX Battery provides power to sensors.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `channel` | the channel to calibrate from 1-8 |\r\n\r\n**Returns** the average sensor value computed by this function\r\n\r\n\r\n"},{"title":"analogRead","href":"#analogRead","content":"\n```\r\nint analogRead ( unsigned char  channel )\r\n```\r\nReads an analog input channel and returns the 12-bit value.\r\n\r\nThe value returned is undefined if the analog pin has been switched to a different mode. This function is Wiring-compatible with the exception of the larger output range. The meaning of the returned value varies depending on the sensor attached.\r\n\r\nThis function may not work properly if the VEX Cortex is tethered to a PC using the orange USB A to A cable and has no VEX 7.2V Battery connected and powered on, as the VEX Battery provides power to sensors.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `channel` | the channel to read from 1-8 |\r\n\r\n**Returns** the analog sensor value, where a value of 0 reflects an input voltage of nearly 0 V and a value of 4095 reflects an input voltage of nearly 5 V\r\n\r\n\r\n"},{"title":"analogReadCalibrated","href":"#analogReadCalibrated","content":"\n```\r\nint analogReadCalibrated ( unsigned char  channel )\r\n```\r\nReads the calibrated value of an analog input channel.\r\n\r\nThe [analogCalibrate()]({{< relref \"#analogCalibrate\" >}}) function must be run first on that channel. This function is inappropriate for sensor values intended for integration, as round-off error can accumulate causing drift over time. Use [analogReadCalibratedHR()]({{< relref \"#analogReadCalibratedHR\" >}}) instead.\r\n\r\nThis function may not work properly if the VEX Cortex is tethered to a PC using the orange USB A to A cable and has no VEX 7.2V Battery connected and powered on, as the VEX Battery provides power to sensors.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `channel` | the channel to read from 1-8 |\r\n\r\n**Returns** the difference of the sensor value from its calibrated default value from -4095 to 4095\r\n\r\n\r\n"},{"title":"analogReadCalibratedHR","href":"#analogReadCalibratedHR","content":"\n```\r\nint analogReadCalibratedHR ( unsigned char  channel )\r\n```\r\nReads the calibrated value of an analog input channel 1-8 with enhanced precision.\r\n\r\nThe [analogCalibrate()]({{< relref \"#analogCalibrate\" >}}) function must be run first. This is intended for integrated sensor values such as gyros and accelerometers to reduce drift due to round-off, and should not be used on a sensor such as a line tracker or potentiometer.\r\n\r\nThe value returned actually has 16 bits of \"precision\", even though the ADC only reads 12 bits, so that errors induced by the average value being between two values come out in the wash when integrated over time. Think of the value as the true value times 16.\r\n\r\nThis function may not work properly if the VEX Cortex is tethered to a PC using the orange USB A to A cable and has no VEX 7.2V Battery connected and powered on, as the VEX Battery provides power to sensors.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `channel` | the channel to read from 1-8 |\r\n\r\n**Returns** the difference of the sensor value from its calibrated default from -16384 to 16384\r\n\r\n\r\n"},{"title":"delay","href":"#delay","content":"\n```\r\nvoid delay ( const unsigned long  time)\r\n```\r\nWiring-compatible alias of [taskDelay()]({{< relref \"#taskDelay\" >}})\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `time` | the duration of the delay in milliseconds (1000 milliseconds per second) |\r\n\r\n\r\n"},{"title":"delayMicroseconds","href":"#delayMicroseconds","content":"\n```\r\nvoid delayMicroseconds ( const unsigned long us )\r\n```\r\nWait for approximately the given number of microseconds.\r\n\r\nThe method used for delaying this length of time may vary depending on the argument. The current task will always be delayed by at least the specified period, but possibly much more depending on CPU load. In general, this function is less reliable than [delay()]({{< relref \"#delay\" >}}). Using this function in a loop may hog processing time from other tasks.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `us` | the duration of the delay in microseconds (1,000,000 microseconds per second) |\r\n\r\n\r\n"},{"title":"digitalRead","href":"#digitalRead","content":"\n```\r\nbool digitalRead ( unsigned char pin )\r\n```\r\nGets the digital value (1 or 0) of a pin configured as a digital input.\r\n\r\nIf the pin is configured as some other mode, the digital value which reflects the current state of the pin is returned, which may or may not differ from the currently set value. The return value is undefined for pins configured as Analog inputs, or for ports in use by a Communications interface. This function is Wiring-compatible.\r\n\r\nThis function may not work properly if the VEX Cortex is tethered to a PC using the orange USB A to A cable and has no VEX 7.2V Battery connected and powered on, as the VEX Battery provides power to sensors.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `pin` | the pin to read from 1-26 |\r\n\r\n**Returns** true if the pin is HIGH or false if it is LOW\r\n\r\n\r\n"},{"title":"digitalWrite","href":"#digitalWrite","content":"\n```\r\nvoid digitalWrite ( unsigned char pin,\r\n                    bool value\r\n                  )\r\n```\r\nSets the digital value (1 or 0) of a pin configured as a digital output.\r\n\r\nIf the pin is configured as some other mode, behavior is undefined. This function is Wiring-compatible.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `pin` | the pin to read from 1-26 |\r\n| `value` | an expression evaluating to \"true\" or \"false\" to set the output to HIGH or LOW respectively, or the constants HIGH or LOW themselves |\r\n\r\n\r\n"},{"title":"encoderGet","href":"#encoderGet","content":"\n```\r\nint encoderGet ( Encoder enc )\r\n```\r\nGets the number of ticks recorded by the encoder.\r\n\r\nThere are 360 ticks in one revolution.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `enc` | the Encoder object from [encoderInit()]({{< relref \"#encoderInit\" >}}) to read |\r\n\r\n**Returns** the signed and cumulative number of counts since the last start or reset\r\n\r\n"},{"title":"encoderInit","href":"#encoderInit","content":"\n```\r\nint encoderInit ( unsigned char portTop,\r\n                  unsigned char portBottom,\r\n                  bool reverse\r\n                )\r\n```\r\nInitializes and enables a quadrature encoder on two digital ports.\r\n\r\nNeither the top port nor the bottom port can be digital port 10. NULL will be returned if either port is invalid or the encoder is already in use. Initializing an encoder implicitly resets its count.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `portTop` | the \"top\" wire from the encoder sensor with the removable cover side UP |\r\n| `portBottom` | the \"bottom\" wire from the encoder sensor |\r\n| `reverse` | if \"true\", the sensor will count in the opposite direction |\r\n\r\n**Returns** an Encoder object to be stored and used for later calls to encoder functions\r\n\r\n\r\n"},{"title":"encoderReset","href":"#encoderReset","content":"\n```\r\nvoid encoderReset ( Encoder enc )\r\n```\r\nResets the encoder to zero.\r\n\r\nIt is safe to use this method while an encoder is enabled. It is not necessary to call this method before stopping or starting an encoder.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `enc` | the Encoder object from [encoderInit()]({{< relref \"#encoderInit\" >}}) to read |\r\n\r\n\r\n"},{"title":"encoderShutdown","href":"#encoderShutdown","content":"\n```\r\nvoid encoderShutdown ( Encoder enc )\r\n```\r\nStops and disables the encoder.\r\n\r\nEncoders use processing power, so disabling unused encoders increases code performance. The encoder's count will be retained.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `enc` | the Encoder object from [encoderInit()]({{< relref \"#encoderInit\" >}}) to read |\r\n\r\n\r\n"},{"title":"fclose","href":"#fclose","content":"\n```\r\nvoid fclose( FILE * stream )\r\n```\r\nCloses the specified file descriptor.\r\n\r\nThis function does not work on communication ports; use [usartShutdown()]({{< relref \"#usartShutdown\" >}}) instead.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `stream` | the file descriptor to close from [fopen()]({{< relref \"#fopen\" >}}) |\r\n\r\n\r\n"},{"title":"fcount","href":"#fcount","content":"\n```\r\nvoid fcount ( FILE * stream )\r\n```\r\nReturns the number of characters that can be read without blocking (the number of characters available) from the specified stream.\r\n\r\nThis only works for communication ports and files in Read mode; for files in Write mode, 0 is always returned.\r\n\r\nThis function may underestimate, but will not overestimate, the number of characters which meet this criterion.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `stream` | the stream to read (stdin, uart1, uart2, or an open file in Read mode) |\r\n\r\n**Returns** the number of characters which meet this criterion; if this number cannot be determined, returns 0\r\n\r\n\r\n"},{"title":"fdelete","href":"#fdelete","content":"\n```\r\nint fdelete ( const char * file )\r\n```\r\nDelete the specified file if it exists and is not currently open.\r\n\r\nThe file will actually be erased from memory on the next re-boot. A physical power cycle is required to purge deleted files and free their allocated space for new files to be written. Deleted files are still considered inaccessible to [fopen()]({{< relref \"#fopen\" >}}) in Read mode.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `file` | the file name to erase |\r\n\r\n**Returns** the number of characters which meet this criterion; if this number cannot be determined, returns 0\r\n\r\n\r\n"},{"title":"feof","href":"#feof","content":"\n```\r\nint feof ( FILE * stream )\r\n```\r\nChecks to see if the specified stream is at its end.\r\n\r\nThis only works for communication ports and files in Read mode; for files in Write mode, 1 is always returned.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `stream` | the stream to read (stdin, uart1, uart2, or an open file in Read mode) |\r\n\r\n**Returns** 0 if the stream is not at EOF, or 1 otherwise.\r\n\r\n"},{"title":"fflush","href":"#fflush","content":"\n```\r\nint fflush ( FILE * stream )\r\n```\r\nFlushes the data on the specified file channel open in Write mode.\r\n\r\nThis function has no effect on a communication port or a file in Read mode, as these streams are always flushed as quickly as possible by the kernel.\r\n\r\nSuccessful completion of an fflush function on a file in Write mode cannot guarantee that the file is vaild until [fclose()]({{< relref \"#fclose\" >}}) is used on that file descriptor.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `stream` | the channel to flush (an open file in Write mode) |\r\n\r\n**Returns** 0 if the data was successfully flushed, EOF otherwise\r\n\r\n"},{"title":"fgetc","href":"#fgetc","content":"\n```\r\nint fgetc ( FILE * stream )\r\n```\r\nReads and returns one character from the specified stream, blocking until complete.\r\n\r\nDo not use [fgetc()]({{< relref \"#fgetc\" >}}) on a VEX LCD port; deadlock may occur.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `stream` | the stream to read (stdin, uart1, uart2, or an open file in Read mode) |\r\n\r\n**Returns** the next character from 0 to 255, or -1 if no character can be read\r\n\r\n"},{"title":"fgets","href":"#fgets","content":"\n```\r\nchar * fgets ( char * str,\r\n               int num,\r\n               FILE * stream\r\n             )\r\n```\r\nReads a string from the specified stream, storing the characters into the memory at str.\r\n\r\nCharacters will be read until the specified limit is reached, a new line is found, or the end of file is reached.\r\n\r\nIf the stream is already at end of file (for files in Read mode), NULL will be returned; otherwise, at least one character will be read and stored into str.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `str` | the location where the characters read will be stored |\r\n| `num` | the maximum number of characters to store; at most (num - 1) characters will be read, with a null terminator ('\\0') automatically appended |\r\n| `stream` | the stream to read (stdin, uart1, uart2, or an open file in Read mode)\r\n\r\n**Returns** str, or NULL if zero characters could be read\r\n\r\n\r\n"},{"title":"fopen","href":"#fopen","content":"\n```\r\nFILE * fopen ( const char * file,\r\n               const char * mode\r\n             )\r\n```\r\nOpens the given file in the specified mode.\r\n\r\nThe file name is truncated to eight characters. Only four files can be in use simultaneously in any given time, with at most one of those files in Write mode. This function does not work on communication ports; use [usartInit()]({{< relref \"#usartInit\" >}}) instead.\r\n\r\nmode can be \"r\" or \"w\". Due to the nature of the VEX Cortex memory, the \"r+\", \"w+\", and \"a\" modes are not supported by the file system.\r\n\r\nOpening a file that does not exist in Read mode will fail and return NULL, but opening a new file in Write mode will create it if there is space. Opening a file that already exists in Write mode will destroy the contents and create a new blank file if space is available.\r\n\r\nThere are important considerations when using of the file system on the VEX Cortex. Reading from files is safe, but writing to files should only be performed when robot actuators have been stopped. PROS will attempt to continue to handle events during file writes, but most user tasks cannot execute during file writing. Powering down the VEX Cortex mid-write may cause file system corruption.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `file` | the file name |\r\n| `mode` | the file mode |\r\n\r\n**Returns** a file descriptor pointing to the new file, or NULL if the file could not be opened\r\n\r\n\r\n"},{"title":"fprint","href":"#fprint","content":"\n```\r\nvoid fprint ( const char * string,\r\n              FILE * stream\r\n            )\r\n```\r\nPrints the simple string to the specified stream.\r\n\r\nThis method is much, much faster than [fprintf()]({{< relref \"#fprintf\" >}}) and does not add a new line like [fputs()]({{< relref \"#fputs\" >}}). Do not use [fprint()]({{< relref \"#fprint\" >}}) on a VEX LCD port. Use [lcdSetText()]({{< relref \"#lcdSetText\" >}}) instead.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `string` | the string to write |\r\n| `stream` | the stream to write (stdout, uart1, uart2, or an open file in Write mode) |\r\n\r\n\r\n"},{"title":"fprintf","href":"#fprintf","content":"\n```\r\nint fprintf ( FILE * stream,\r\n              const char * formatString,\r\n              ...\r\n            )\r\n```\r\nPrints the formatted string to the specified output stream.\r\n\r\nThe specifiers supported by this minimalistic printf() function are:\r\n\r\n * %d: Signed integer in base 10 (int)\r\n * %u: Unsigned integer in base 10 (unsigned int)\r\n * %x, %X: Integer in base 16 (unsigned int, int)\r\n * %p: Pointer (void \\*, int \\*, ...)\r\n * %c: Character (char)\r\n * %s: Null-terminated string (char \\*)\r\n * %%: Single literal percent sign\r\n * %f: Floating-point number\r\n\r\nSpecifiers can be modified with:\r\n\r\n * 0: Zero-pad, instead of space-pad\r\n * a.b: Make the field at least \"a\" characters wide. If \"b\" is specified for \"%f\", changes the number of digits after the decimal point\r\n * -: Left-align, instead of right-align\r\n * +: Always display the sign character (displays a leading \"+\" for positive numbers)\r\n * l: Ignored for compatibility\r\n\r\nInvalid format specifiers, or mismatched parameters to specifiers, cause undefined behavior. Other characters are written out verbatim. Do not use [fprintf()]({{< relref \"#fprintf\" >}}) on a VEX LCD port. Use [lcdPrint()]({{< relref \"#lcdPrint\" >}}) instead.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `stream` | the stream to write (stdout, uart1, uart2, or an open file in Write mode) |\r\n| `formatString` | the format string as specified above |\r\n\r\n**Returns** the number of characters written\r\n\r\n"},{"title":"fputc","href":"#fputc","content":"\n```\r\nint fputc ( int value,\r\n            FILE * stream\r\n          )\r\n```\r\nWrites one character to the specified stream.\r\n\r\nDo not use [fputc()]({{< relref \"#fputc\" >}}) on a VEX LCD port. Use [lcdSetText()]({{< relref \"#lcdSetText\" >}}) instead.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `value` | the character to write (a value of type \"char\" can be used) |\r\n| `stream` | the stream to write (stdout, uart1, uart2, or an open file in Write mode) |\r\n\r\n**Returns** the character written\r\n\r\n\r\n"},{"title":"fputs","href":"#fputs","content":"\n```\r\nint fputs ( const char * string,\r\n            FILE * stream\r\n          )\r\n```\r\nBehaves the same as the \"fprint\" function, and appends a trailing newline (\"\\n\").\r\n\r\nDo not use [fputs()]({{< relref \"#fputs\" >}}) on a VEX LCD port. Use [lcdSetText()]({{< relref \"#lcdSetText\" >}}) instead.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `string` | the string to write |\r\n| `stream` | the stream to write (stdout, uart1, uart2, or an open file in Write mode) |\r\n\r\n**Returns** the number of characters written, excluding the new line\r\n\r\n\r\n"},{"title":"fread","href":"#fread","content":"\n```\r\nsize_t fread ( void * ptr,\r\n               size_t size,\r\n               size_t count,\r\n               FILE * stream\r\n             )\r\n```\r\nReads data from a stream into memory.\r\n\r\nIf the memory at ptr cannot store (size * count) bytes, undefined behavior occurs.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `ptr` | a pointer to where the data will be stored |\r\n| `size` | \tthe size of each data element to read in bytes |\r\n| `count` | the number of data elements to read |\r\n| `stream` | the stream to read (stdout, uart1, uart2, or an open file in Read mode) |\r\n\r\n**Returns** the number of bytes successfully read\r\n\r\n\r\n"},{"title":"fseek","href":"#fseek","content":"\n```\r\nint fseek ( FILE * stream,\r\n            long int offset,\r\n            int origin\r\n          )\r\n```\r\nSeeks within a file open in Read mode.\r\n\r\nThis function will fail when used on a file in Write mode or on any communications port.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `stream` | the stream to seek within |\r\n| `offset` | the location within the stream to seek |\r\n| `origin` | the reference location for offest: SEEK_CUR, SEEK_SET, or SEEK_END |\r\n\r\n**Returns** 0 if the seek was successful, or 1 otherwise\r\n\r\n\r\n"},{"title":"ftell","href":"#ftell","content":"\n```\r\nlong int ftell ( FILE * stream )\r\n```\r\nReturns the current position of the stream.\r\n\r\nThis function works on files in either Read or Write mode, but will fail on communications ports.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `stream` | the stream to check |\r\n\r\n**Returns** the offset of the stream, or -1 if the offset could not be determined\r\n\r\n\r\n"},{"title":"fwrite","href":"#fwrite","content":"\n```\r\nsize_t fwrite ( const void * ptr,\r\n                size_t size,\r\n                size_t count,\r\n                FILE * stream\r\n              )\r\n```\r\nWrites data from memory to a stream.\r\n\r\nReturns the number of bytes thus written.\r\n\r\nIf the memory at ptr is not as long as (size * count) bytes, undefined behavior occurs.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `ptr` | a pointer to the data to write |\r\n| `size` | the size of each data element to write in bytes |\r\n| `count` | the number of data elements to write |\r\n| `stream` | the stream to write (stdout, uart1, uart2 or an open file in Write mode) |\r\n\r\n**Returns** the number of bytes successfully written\r\n\r\n"},{"title":"getchar","href":"#getchar","content":"\n```\r\nint getchar ( )\r\n```\r\nReads and returns one character from \"stdin\", which is the PC debug terminal.\r\n\r\n**Returns** the next character from 0 to 255, or -1 if no character can be read\r\n\r\n"},{"title":"gyroGet","href":"#gyroGet","content":"\n```\r\nint gyroGet ( Gyro gyro )\r\n```\r\nGets the current gyro angle in degrees, rounded to the nearest degree.\r\n\r\nThere are 360 degrees in a circle.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `gyro` | the Gyro object from [gyroInit()]({{< relref \"#gyroInit\" >}}) to read |\r\n\r\n**Returns** the signed and cumulative number of degrees rotated around the gyro's vertical axis since the last start or reset\r\n\r\n\r\n"},{"title":"gyroInit","href":"#gyroInit","content":"\n```\r\nGyro gyroInit ( unsigned char port,\r\n                unsigned short multiplier\r\n              )\r\n```\r\nInitializes and enables a gyro on an analog port.\r\n\r\nNULL will be returned if the port is invalid or the gyro is already in use. Initializing a gyro implicitly calibrates it and resets its count. Do not move the robot while the gyro is being calibrated. It is suggested to call this function in initialize() and to place the robot in its final position before powering it on.\r\n\r\nThe multiplier parameter can tune the gyro to adapt to specific sensors. The default value at this time is 196; higher values will increase the number of degrees reported for a fixed actual rotation, while lower values will decrease the number of degrees reported. If your robot is consistently turning too far, increase the multiplier, and if it is not turning far enough, decrease the multiplier.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `port` | the analog port to use from 1-8 |\r\n| `multiplier` | an optional constant to tune the gyro readings; use 0 for the default value |\r\n\r\n**Returns** a Gyro object to be stored and used for later calls to gyro functions\r\n\r\n"},{"title":"gyroReset","href":"#gyroReset","content":"\n```\r\nvoid gyroReset ( Gyro gyro )\r\n```\r\nResets the gyro to zero.\r\n\r\nIt is safe to use this method while a gyro is enabled. It is not necessary to call this method before stopping or starting a gyro.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `gyro` | the Gyro object from [gyroInit()]({{< relref \"#gyroInit\" >}}) to reset |\r\n\r\n\r\n"},{"title":"gyroShutdown","href":"#gyroShutdown","content":"\n```\r\nvoid gyroShutdown ( Gyro gyro )\r\n```\r\nStops and disables the gyro.\r\n\r\nGyros use processing power, so disabling unused gyros increases code performance. The gyro's position will be retained.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `gyro` | the Gyro object from [gyroInit()]({{< relref \"#gyroInit\" >}}) to stop |\r\n\r\n"},{"title":"i2cRead","href":"#i2cRead","content":"\n```\r\nbool i2cRead ( uint8_t addr,\r\n               uint8_t * data,\r\n               uint16_t count\r\n             )\r\n```\r\nReads the specified number of data bytes from the specified 7-bit I2C address. The bytes will be stored at the specified location.\r\n\r\nThe I2C address should be right-aligned; the R/W bit is automatically supplied.\r\n\r\nSince most I2C devices use an 8-bit register architecture, this method has limited usefulness. Consider [i2cReadRegister()]({{< relref \"#i2cReadRegister\" >}}) instead for the vast majority of applications.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `addr` | address to read |\r\n| `data` | a pointer to the location where the value will be stored |\r\n| `count`| number of bytes to read |\r\n\r\n**Returns** true if successful or false if failed. If only some bytes could be read, false is still returned.\r\n\r\n\r\n"},{"title":"i2cReadRegister","href":"#i2cReadRegister","content":"\n```\r\nbool i2cReadRegister ( uint8_t addr,\r\n                       uint8_t * data,\r\n                       uint16_t count\r\n                     )\r\n```\r\nReads the specified amount of data from the given register address on the specified 7-bit I2C address.\r\n\r\nThe I2C address should be right-aligned; the R/W bit is automatically supplied.\r\n\r\nMost I2C devices support an auto-increment address feature, so using this method to read more than one byte will usually read a block of sequential registers. Try to merge reads to separate registers into a larger read using this function whenever possible to improve code reliability, even if a few intermediate values need to be thrown away.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `addr` | register address to read |\r\n| `data` | a pointer to the location where the value will be stored |\r\n| `count`| number of bytes to read |\r\n\r\n**Returns** true if successful or false if failed. If only some bytes could be read, false is still returned.\r\n\r\n\r\n"},{"title":"i2cWrite","href":"#i2cWrite","content":"\n```\r\nbool i2cWrite ( uint8_t addr,\r\n                uint8_t * data,\r\n                uint16_t count\r\n              )\r\n```\r\nWrites the specified number of data bytes to the specified 7-bit I2C address.\r\n\r\nThe I2C address should be right-aligned; the R/W bit is automatically supplied.\r\n\r\nSince most I2C devices use an 8-bit register architecture, this method is mostly useful for setting the register position (most devices remember the last-used address) or writing a sequence of bytes to one register address using an auto-increment feature. In these cases, the first byte written from the data buffer should have the register address to use.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `addr` | address to write to |\r\n| `data` | a pointer to the data to be written |\r\n| `count`| number of bytes to write |\r\n\r\n**Returns** true if successful or false if failed. If only some bytes could be written, false is still returned.\r\n\r\n"},{"title":"i2cWriteRegister","href":"#i2cWriteRegister","content":"\n```\r\nbool i2cWriteRegister ( uint8_t addr,\r\n                        uint8_t reg,\r\n                        uint16_t value\r\n                      )\r\n```\r\nWrites the specified data byte to a register address on the specified 7-bit I2C address.\r\n\r\nThe I2C address should be right-aligned; the R/W bit is automatically supplied.\r\n\r\nOnly one byte can be written to each register address using this method. While useful for the vast majority of I2C operations, writing multiple bytes requires the i2cWrite method.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `addr` | base address of i2c device |\r\n| `reg` | register address to be written to |\r\n| `value`| byte to write to register |\r\n\r\n**Returns** true if successful or false if failed\r\n\r\n"},{"title":"imeGet","href":"#imeGet","content":"\n```\r\nbool imeGet ( unsigned char address,\r\n              int * value\r\n            )\r\n```\r\nGets the current 32-bit count of the specified IME.\r\n\r\nMuch like the count for a quadrature encoder, the tick count is signed and cumulative. The value reflects total counts since the last reset. Different VEX Motor Encoders have a different number of counts per revolution:\r\n\r\n * 240.448 for the 269 IME\r\n * 627.2 for the 393 IME in high torque mode (factory default)\r\n * 392 for the 393 IME in high speed mode\r\n * 261.333 for the 393 IME in turbo mode\r\n\r\nIf the IME address is invalid, or the IME has not been reset or initialized, the value stored in \\*value is undefined.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `address` | the IME address to fetch from 0 to IME_ADDR_MAX |\r\n| `value`   | a pointer to the location where the value will be stored (obtained using the \"&\" operator on the target variable name e.g. imeGet(2, &counts)) |\r\n\r\n**Returns** true if the count was successfully read and the value stored in \\*value is valid; false otherwise\r\n\r\n\r\n\r\n"},{"title":"imeGetVelocity","href":"#imeGetVelocity","content":"\n```\r\nbool imeGetVelocity ( unsigned char address,\r\n                      int * value\r\n                    )\r\n```\r\nGets the current rotational velocity of the specified IME.\r\n\r\nIn this version of PROS, the velocity is positive if the IME count is increasing and negative if the IME count is decreasing. The velocity is in RPM of the internal encoder wheel. Since checking the IME for its type cannot reveal whether the motor gearing is high speed or high torque (in the 2-Wire Motor 393 case), the user must divide the return value by the number of output revolutions per encoder revolution:\r\n\r\n * 30.056 for the 269 IME\r\n * 39.2 for the 393 IME in high torque mode (factory default)\r\n * 24.5 for the 393 IME in high speed mode\r\n\r\nIf the IME address is invalid, or the IME has not been reset or initialized, the value stored in \\*value is undefined.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `address` | the IME address to fetch from 0 to IME_ADDR_MAX |\r\n| `value`   | a pointer to the location where the value will be stored (obtained using the \"&\" operator on the target variable name e.g. imeGet(imeGetVelocity, &counts)) |\r\n\r\n_**Returns**_ true if the velocity was successfully read and the value stored in \\*value is valid; false otherwise\r\n\r\n\r\n"},{"title":"imeInitializeAll","href":"#imeInitializeAll","content":"\n```\r\nunsigned int imeInitializeAll ( )\r\n```\r\nInitializes all IMEs.\r\n\r\nIMEs are assigned sequential incrementing addresses, beginning with the first IME on the chain (closest to the VEX Cortex I2C port). Therefore, a given configuration of IMEs will always have the same ID assigned to each encoder. The addresses range from 0 to IME_ADDR_MAX, so the first encoder gets 0, the second gets 1, ...\r\n\r\nThis function should most likely be used in initialize(). Do not use it in initializeIO() or at any other time when the scheduler is paused (like an interrupt). Checking the return value of this function is important to ensure that all IMEs are plugged in and responding as expected.\r\n\r\nThis function, unlike the other IME functions, is not thread safe. If using imeInitializeAll to re-initialize encoders, calls to other IME functions might behave unpredictably during this function's execution.\r\n\r\n**Returns** the number of IMEs successfully initialized\r\n\r\n\r\n"},{"title":"imeReset","href":"#imeReset","content":"\n```\r\nbool imeReset ( unsigned char address )\r\n```\r\nResets the specified IME's counters to zero.\r\n\r\nThis method can be used while the IME is rotating.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `address` | the IME address to fetch from 0 to IME_ADDR_MAX |\r\n\r\n**Returns** true if the reset succeeded; false otherwise\r\n\r\n\r\n"},{"title":"imeShutdown","href":"#imeShutdown","content":"\n```\r\nvoid imeShutdown ( )\r\n```\r\nShuts down all IMEs on the chain; their addresses return to the default and the stored counts and velocities are lost.\r\n\r\nThis function, unlike the other IME functions, is not thread safe.\r\n\r\nTo use the IME chain again, wait at least 0.25 seconds before using imeInitializeAll again.\r\n\r\n\r\n"},{"title":"ioClearInterrupt","href":"#ioClearInterrupt","content":"\n```\r\nvoid ioClearInterrupt ( unsigned char pin )\r\n```\r\nDisables interrupts on the specified pin.\r\n\r\nDisabling interrupts on interrupt pins which are not in use conserves processing time.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `pin` | the pin on which to reset interrupts from 1-9,11-12 |\r\n\r\n\r\n"},{"title":"ioSetInterrupt","href":"#ioSetInterrupt","content":"\n```\r\nvoid ioSetInterrupt( unsigned char    pin,\r\n                     unsigned char    edges,\r\n                     InterruptHandler handler\r\n                   )\r\n```\r\nSets up an interrupt to occur on the specified pin, and resets any counters or timers associated with the pin.\r\n\r\nEach time the specified change occurs, the function pointer passed in will be called with the pin that changed as an argument. Enabling pin-change interrupts consumes processing time, so it is best to only enable necessary interrupts and to keep the InterruptHandler function short. Pin change interrupts can only be enabled on pins 1-9 and 11-12.\r\n\r\nDo not use API functions such as [delay()]({{< relref \"#delay\" >}}) inside the handler function, as the function will run in an ISR where the scheduler is paused and no other interrupts can execute. It is best to quickly update some state and allow a task to perform the work.\r\n\r\nDo not use this function on pins that are also being used by the built-in ultrasonic or shaft encoder drivers, or on pins which have been switched to output mode.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `pin`| the pin on which to enable interrupts from 1-9,11-12 |\r\n| `edges`| one of INTERRUPT_EDGE_RISING, INTERRUPT_EDGE_FALLING, or INTERRUPT_EDGE_BOTH |\r\n| `handler`| the function to call when the condition is satisfied|\r\n\r\n\r\n"},{"title":"isAutonomous","href":"#isAutonomous","content":"\n```\r\nbool isAutonomous ( )\r\n```\r\nWhile in autonomous mode, joystick inputs will return a neutral value, but serial port communications (even over VexNET) will still work properly.\r\n\r\n**Returns** true if the robot is in autonomous mode, or false otherwise.\r\n\r\n\r\n"},{"title":"isEnabled","href":"#isEnabled","content":"\n```\r\nbool isEnabled ( )\r\n```\r\nWhile disabled via the VEX Competition Switch or VEX Field Controller, motors will not function. However, the digital I/O ports can still be changed, which may indirectly affect the robot state (e.g. solenoids). Avoid performing externally visible actions while disabled (the kernel should take care of this most of the time).\r\n\r\n**Returns** true if the robot is enabled, or false otherwise.\r\n\r\n\r\n"},{"title":"isJoystickConnected","href":"#isJoystickConnected","content":"\n```\r\nbool isJoystickConnected ( unsigned char joystick )\r\n```\r\nUseful for automatically merging joysticks for one operator, or splitting for two. This function does not work properly during initialize() or initializeIO() and can return false positives. It should be checked once and stored at the beginning of operatorControl().\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `joystick` | the joystick slot to check |\r\n\r\n**Returns** true if a joystick is connected to the specified slot number (1 or 2), or false otherwise.\r\n\r\n\r\n\r\n"},{"title":"isOnline","href":"#isOnline","content":"\n```\r\nbool isOnline ( )\r\n```\r\nWhen in online mode, the switching between autonomous() and operatorControl() tasks is managed by the PROS kernel.\r\n\r\n**Returns** true if a VEX field controller or Competition switch is connected, or false otherwise\r\n\r\n"},{"title":"joystickGetAnalog","href":"#joystickGetAnalog","content":"\n```\r\nint joystickGetAnalog ( unsigned char joystick,\r\n                        unsigned char axis\r\n                      )\r\n```\r\nGets the value of a control axis on the VEX joystick.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `joystick` | the joystick slot to check |\r\n| `axis` | one of the 1, 2, 3, 4, ACCEL_X, or ACCEL_Y anaglog channels on a Vex joystick |\r\n\r\n**Returns** the value from -127 to 127, or 0 if no joystick is connected to the requested slot.\r\n\r\n\r\n"},{"title":"joystickGetDigital","href":"#joystickGetDigital","content":"\n```\r\nint joystickGetDigital ( unsigned char joystick,\r\n                         unsigned char buttonGroup,\r\n                         unsigned char button\r\n                       )\r\n```\r\nGets the value of a button on the VEX joystick.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `joystick` | the joystick slot to check |\r\n| `buttonGroup` | one of 5, 6, 7, or 8 to request that button as labelled on the joystick |\r\n| `button` | one of JOY_UP, JOY_DOWN, JOY_LEFT, or JOY_RIGHT; requesting JOY_LEFT or JOY_RIGHT for groups 5 or 6 will cause an undefined value to be returned |\r\n\r\n**Returns** true if that button is pressed, or false otherwise. If no joystick is connected to the requested slot, returns false.\r\n\r\n\r\n"},{"title":"lcdClear","href":"#lcdClear","content":"\n```\r\nvoid lcdClear ( FILE * lcdPort )\r\n```\r\nClears the LCD screen on the specified port.\r\n\r\nPrinting to a line implicitly overwrites the contents, so clearing should only be required at startup.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `lcdPort` | the LCD to clear, either uart1 or uart2 |\r\n\r\n\r\n"},{"title":"lcdInit","href":"#lcdInit","content":"\n```\r\nvoid lcdInit ( FILE * lcdPort )\r\n```\r\nInitializes the LCD port, but does not change the text or settings.\r\n\r\nIf the LCD was not initialized before, the text currently on the screen will be undefined. The port will not be usable with standard serial port functions until the LCD is stopped.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `lcdPort` | the LCD to clear, either uart1 or uart2 |\r\n\r\n\r\n"},{"title":"lcdPrint","href":"#lcdPrint","content":"\n```\r\nvoid lcdPrint ( FILE * lcdPort,\r\n                unsigned char line,\r\n                const char * formatString,\r\n                ...\r\n              )\r\n```\r\nPrints the formatted string to the attached LCD.\r\n\r\nThe output string will be truncated as necessary to fit on the LCD screen, 16 characters wide. It is probably better to generate the string in a local buffer and use [lcdSetText()]({{< relref \"#lcdSetText\" >}}) but this method is provided for convenience.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `lcdPort` | the LCD to clear, either uart1 or uart2 |\r\n| `line` | the LCD line to write, either 1 or 2 |\r\n| `formatString` | the format string as specified in [fprintf()]({{< relref \"#fprintf\" >}}) |\r\n\r\n\r\n"},{"title":"lcdReadButtons","href":"#lcdReadButtons","content":"\n```\r\nunsigned int lcdReadButtons (FILE * lcdPort )\r\n```\r\nReads the user button status from the LCD display.\r\n\r\nFor example, if the left and right buttons are pushed, (1 | 4) = 5 will be returned. 0 is returned if no buttons are pushed\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `lcdPort` | the LCD to clear, either uart1 or uart2 |\r\n\r\n**Returns** the buttons pressed as a bit mask\r\n\r\n\r\n"},{"title":"lcdSetBacklight","href":"#lcdSetBacklight","content":"\n```\r\nvoid lcdSetBacklight ( FILE * lcdPort,\r\n                       bool backlight\r\n                     )\r\n```\r\nSets the specified LCD backlight to be on or off.\r\n\r\nTurning it off will save power but may make it more difficult to read in dim conditions.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `lcdPort` | the LCD to clear, either uart1 or uart2 |\r\n| `backlight` | true to turn the backlight on, or false to turn it off\r\n\r\n\r\n"},{"title":"lcdSetText","href":"#lcdSetText","content":"\n```\r\nvoid lcdSetText ( FILE * lcdPort,\r\n                  unsigned char line,\r\n                  const char * buffer\r\n                )\r\n```\r\nPrints the string buffer to the attached LCD.\r\n\r\nThe output string will be truncated as necessary to fit on the LCD screen, 16 characters wide. This function, like [fprint()]({{< relref \"#fprintf\" >}}), is much, much faster than a formatted routine such as [lcdPrint()]({{< relref \"#lcdPrint\" >}}) and consumes less memory.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `lcdPort` | the LCD to clear, either uart1 or uart2 |\r\n| `line` | the LCD line to write, either 1 or 2 |\r\n| `buffer` | the string to write |\r\n\r\n\r\n"},{"title":"lcdShutdown","href":"#lcdShutdown","content":"\n```\r\nvoid lcdShutdown ( FILE * lcdPort )\r\n```\r\nShut down the specified LCD port.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `lcdPort` | the LCD to clear, either uart1 or uart2 |\r\n\r\n\r\n"},{"title":"micros","href":"#micros","content":"\n```\r\nunsigned long micros ( )\r\n```\r\nThere are 10^6 microseconds in a second, so as a 32-bit integer, this will overflow and wrap back to zero every two hours or so.\r\n\r\nThis function is Wiring-compatible.\r\n\r\n**Returns** the number of microseconds since the Cortex was turned on or the last overflow\r\n\r\n\r\n"},{"title":"millis","href":"#millis","content":"\n```\r\nunsigned long millis ( )\r\n```\r\nThere are 1000 milliseconds in a second, so as a 32-bit integer, this will not overflow for 50 days.\r\n\r\nThis function is Wiring-compatible.\r\n\r\n**Returns**  the number of milliseconds since Cortex power-up.\r\n\r\n\r\n"},{"title":"motorGet","href":"#motorGet","content":"\n```\r\nint motorGet ( unsigned char channel )\r\n```\r\nGets the last set speed of the specified motor channel.\r\n\r\nThis speed may have been set by any task or the PROS kernel itself. This is not guaranteed to be the speed that the motor is actually running at, or even the speed currently being sent to the motor, due to latency in the Motor Controller 29 protocol and physical loading. To measure actual motor shaft revolution speed, attach a VEX Integrated Motor Encoder or VEX Quadrature Encoder and use the velocity functions associated with each.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `channel` | channel\tthe motor channel to fetch from 1-10 |\r\n\r\n**Returns** the speed last sent to this channel; -127 is full reverse and 127 is full forward, with 0 being off\r\n\r\n\r\n"},{"title":"motorSet","href":"#motorSet","content":"\n```\r\nvoid motorSet ( unsigned char channel,\r\n                int speed\r\n              )\r\n```\r\nSets the speed of the specified motor channel.\r\n\r\nDo not use [motorSet()]({{< relref \"#motorSet\" >}}) with the same channel argument from two different tasks. It is safe to use [motorSet()]({{< relref \"#motorSet\" >}}) with different channel arguments from different tasks.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `channel` | channel\tthe motor channel to fetch from 1-10 |\r\n| `speed` | the new signed speed; -127 is full reverse and 127 is full forward, with 0 being off\r\n\r\n\r\n"},{"title":"motorStop","href":"#motorStop","content":"\n```\r\nvoid motorStop ( unsigned char channel )\r\n```\r\nStops the motor on the specified channel, equivalent to calling [motorSet()]({{< relref \"#motorSet\" >}}) with an argument of zero.\r\n\r\nThis performs a coasting stop, not an active brake. Since motorStop is similar to motorSet(0), see the note for [motorSet()]({{< relref \"#motorSet\" >}}) about use from multiple tasks.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `channel` | channel\tthe motor channel to fetch from 1-10 |\r\n\r\n\r\n"},{"title":"mutexCreate","href":"#mutexCreate","content":"\n```\r\nMutex mutexCreate ( )\r\n```\r\nCreates a mutex intended to allow only one task to use a resource at a time.\r\n\r\nFor signalling and synchronization, try using semaphores.\r\n\r\nMutexes created using this function can be accessed using the [mutexTake()]({{< relref \"#mutexTake\" >}}) and [mutexGive()]]({{< relref \"#mutexGive\" >}}) functions. The semaphore functions must not be used on objects of this type.\r\n\r\nThis type of object uses a priority inheritance mechanism so a task 'taking' a mutex MUST ALWAYS 'give' the mutex back once the mutex is no longer required.\r\n\r\n**Returns** a handle to the created mutex\r\n\r\n\r\n"},{"title":"mutexDelete","href":"#mutexDelete","content":"\n```\r\nvoid mutexDelete ( Mutex mutex )\r\n```\r\nDeletes the specified mutex.\r\n\r\nThis function can be dangerous; deleting semaphores being waited on by a task may cause deadlock or a crash.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `mutex` | the mutex to destroy |\r\n\r\n\r\n"},{"title":"mutexGive","href":"#mutexGive","content":"\n```\r\nbool mutexGive ( Mutex mutex )\r\n```\r\nRelinquishes a mutex so that other tasks can use the resource it guards.\r\n\r\nThe mutex must be held by the current task using a corresponding call to [mutexTake()]({{< relref \"#mutexTake\" >}}).\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `mutex` | the mutex to release |\r\n\r\n**Returns** true if the mutex was released, or false if the mutex was not already held\r\n\r\n\r\n"},{"title":"mutexTake","href":"#mutexTake","content":"\n```\r\nbool mutexTake ( Mutex mutex,\r\n                 const unsigned long blockTime\r\n               )\r\n```\r\nRequests a mutex so that other tasks cannot simultaneously use the resource it guards.\r\n\r\nThe mutex must not already be held by the current task. If another task already holds the mutex, the function will wait for the mutex to be released. Other tasks can run during this time.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `mutex` | the mutex to request |\r\n| `blocktime` | the maximum time to wait for the mutex to be available, where -1 specifies an infinite timeout |\r\n\r\n**Returns** true if the mutex was successfully taken, or false if the timeout expired\r\n\r\n\r\n"},{"title":"pinMode","href":"#pinMode","content":"\n```\r\nvoid pinMode ( unsigned char pin,\r\n               unsigned char mode\r\n             )\r\n```\r\nConfigures the pin as an input or output with a variety of settings.\r\n\r\nDo note that INPUT by default turns on the pull-up resistor, as most VEX sensors are open-drain active low. It should not be a big deal for most push-pull sources. This function is Wiring-compatible.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `pin` | the pin to read from 1-26 |\r\n| `mode` | one of INPUT, INPUT_ANALOG, INPUT_FLOATING, OUTPUT, or OUTPUT_OD\r\n\r\n\r\n"},{"title":"powerLevelBackup","href":"#powerLevelBackup","content":"\n```\r\nunsigned int powerLevelBackup ( )\r\n```\r\n**Returns** the backup battery voltage in millivolts. If no backup battery is connected, returns 0\r\n\r\n\r\n\r\n"},{"title":"powerLevelMain","href":"#powerLevelMain","content":"\n```\r\nunsigned int powerLevelMain ( )\r\n```\r\nIn rare circumstances, this method might return 0. Check the output value for reasonability before blindly blasting the user.\r\n\r\n**Returns** the main battery voltage in millivolts\r\n\r\n\r\n"},{"title":"print","href":"#print","content":"\n```\r\nvoid print ( const char * string )\r\n```\r\nPrints the simple string to the debug terminal without formatting.\r\n\r\nThis method is much, much faster than [printf()]({{< relref \"#printf\" >}}).\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `string` the string to write |\r\n\r\n\r\n"},{"title":"printf","href":"#printf","content":"\n```\r\nint printf ( const char * formatString,\r\n             ...\r\n           )\r\n```\r\nPrints the formatted string to the debug stream (the PC terminal).\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `formatString` | the format string as specified in [fprintf()]({{< relref \"#fprintf\" >}}) |\r\n\r\n**Returns** the number of characters written\r\n\r\n\r\n"},{"title":"putchar","href":"#putchar","content":"\n```\r\nint putchar ( int value )\r\n```\r\nWrites one character to \"stdout\", which is the PC debug terminal, and returns the input value.\r\n\r\nWhen using a wireless connection, one may need to press the spacebar before the input is visible on the terminal.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `value` | the character to write (a value of type \"char\" can be used) |\r\n\r\n**Returns** the number of characters writen, excluding the new line\r\n\r\n\r\n"},{"title":"semaphoreCreate","href":"#semaphoreCreate","content":"\n```\r\nSemaphore semaphoreCreate ( )\r\n```\r\nCreates a semaphore intended for synchronizing tasks.\r\n\r\nTo prevent some critical code from simultaneously modifying a shared resource, use mutexes instead.\r\n\r\nSemaphores created using this function can be accessed using the [semaphoreTake()]({{< relref \"#semaphoreTake\" >}}) and [semaphoreGive()]({{< relref \"#semaphoreGive\" >}}) functions. The mutex functions must not be used on objects of this type.\r\n\r\nThis type of object does not need to have balanced take and give calls, so priority inheritance is not used. Semaphores can be signalled by an interrupt routine.\r\n\r\n**Returns** a handle to the created semaphore\r\n\r\n\r\n"},{"title":"semaphoreDelete","href":"#semaphoreDelete","content":"\n```\r\nvoid semaphoreDelete ( Semaphore semaphore )\r\n```\r\nDeletes the specified semaphore.\r\n\r\nThis function can be dangerous; deleting semaphores being waited on by a task may cause deadlock or a crash.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `semaphore` | the semaphore to destroy |\r\n\r\n\r\n"},{"title":"semaphoreGive","href":"#semaphoreGive","content":"\n```\r\nbool semaphoreGive (Semaphore semaphore )\r\n```\r\nSignals a semaphore.\r\n\r\nTasks waiting for a signal using [semaphoreTake()]({{< relref \"#semaphoreTake\" >}}) will be unblocked by this call and can continue execution.\r\n\r\nSlow processes can give semaphores when ready, and fast processes waiting to take the semaphore will continue at that point.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `semaphore` | the semaphore to destroy |\r\n\r\n**Returns** true if the semaphore was successfully given, or false if the semaphore was not taken since the last give\r\n\r\n\r\n"},{"title":"semaphoreTake","href":"#semaphoreTake","content":"\n```\r\nbool semaphoreTake ( Semaphore semaphore,\r\n                     const unsigned long blockTime\r\n                   )\r\n```\r\nWaits on a semaphore.\r\n\r\nIf the semaphore is already in the \"taken\" state, the current task will wait for the semaphore to be signaled. Other tasks can run during this time.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `semaphore` | the semaphore to wait |\r\n| `blockTime` | the maximum time to wait for the semaphore to be given, where -1 specifies an infinite timeout |\r\n\r\n**Returns** true if the semaphore was successfully taken, or false if the timeout expired\r\n\r\n\r\n"},{"title":"setTeamName","href":"#setTeamName","content":"\n```\r\nvoid setTeamName ( const char * name )\r\n```\r\nSets the team name displayed to the VEX field control and VEX Firmware Upgrade.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `name` | a string containing the team name; only the first eight characters will be shown |\r\n\r\n\r\n"},{"title":"snprintf","href":"#snprintf","content":"\n```\r\nint snprintf ( char * buffer,\r\n               size_t limit,\r\n               const char * formatString,\r\n               ...\r\n             )\r\n```\r\nPrints the formatted string to the string buffer with the specified length limit.\r\n\r\nThe length limit, as per the C standard, includes the trailing null character, so an argument of 256 will cause a maximum of 255 non-null characters to be printed, and one null terminator in all cases.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `buffer` | the string buffer where characters can be placed |\r\n| `limit` | the maximum number of characters to write |\r\n| `formatString` | the format string as specified in [fprintf()]({{< relref \"#fprintf\" >}}) |\r\n\r\n**Returns** the number of characters stored\r\n\r\n\r\n"},{"title":"speakerInit","href":"#speakerInit","content":"\n```\r\nvoid speakerInit ( )\r\n```\r\nInitializes VEX speaker support.\r\n\r\nThe VEX speaker is not thread safe; it can only be used from one task at a time. Using the VEX speaker may impact robot performance. Teams may benefit from an if statement that only enables sound if [isOnline()]({{< relref \"#isOnline\" >}}) returns false.\r\n\r\n\r\n"},{"title":"speakerPlayArray","href":"#speakerPlayArray","content":"\n```\r\nvoid speakerPlayArray ( const char ** songs )\r\n```\r\nPlays up to three RTTTL (Ring Tone Text Transfer Language) songs simultaneously over the VEX speaker.\r\n\r\nThe audio is mixed to allow polyphonic sound to be played. Many simple songs are available in RTTTL format online, or compose your own.\r\n\r\nThe song must not be NULL, but unused tracks within the song can be set to NULL. If any of the three song tracks is invalid, the result of this function is undefined.\r\n\r\nThe VEX speaker is not thread safe; it can only be used from one task at a time. Using the VEX speaker may impact robot performance. Teams may benefit from an if statement that only enables sound if [isOnline()]({{< relref \"#isOnline\" >}}) returns false.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `songs` | an array of up to three (3) RTTTL songs as string values to play |\r\n\r\n\r\n"},{"title":"speakerPlayRtttl","href":"#speakerPlayRtttl","content":"\n```\r\nvoid speakerPlayRtttl ( const char * song )\r\n```\r\nPlays an RTTTL (Ring Tone Text Transfer Language) song over the VEX speaker.\r\n\r\nMany simple songs are available in RTTTL format online, or compose your own.\r\n\r\nThe song must not be NULL. If an invalid song is specified, the result of this function is undefined.\r\n\r\nThe VEX speaker is not thread safe; it can only be used from one task at a time. Using the VEX speaker may impact robot performance. Teams may benefit from an if statement that only enables sound if [isOnline()]({{< relref \"#isOnline\" >}}) returns false.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `song` | \tthe RTTTL song as a string value to play |\r\n\r\n\r\n"},{"title":"speakerShutdown","href":"#speakerShutdown","content":"\n```\r\nvoid speakerShutdown ( )\r\n```\r\nPowers down and disables the VEX speaker.\r\n\r\nIf a song is currently being played in another task, the behavior of this function is undefined, since the VEX speaker is not thread safe.\r\n\r\n\r\n"},{"title":"sprintf","href":"#sprintf","content":"\n```\r\nint sprintf ( char * buffer,\r\n               const char * formatString,\r\n               ...\r\n             )\r\n```\r\nPrints the formatted string to the string buffer.\r\n\r\nIf the buffer is not big enough to contain the complete formatted output, undefined behavior occurs. See [snprintf()]({{< relref \"#snprintf\" >}}) for a safer version of this function.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `buffer` | the string buffer where characters can be placed |\r\n| `formatString` | the format string as specified in [fprintf()]({{< relref \"#fprintf\" >}}) |\r\n\r\n**Returns** the number of characters stored\r\n\r\n"},{"title":"taskCreate","href":"#taskCreate","content":"\n```\r\nTaskHandle taskCreate ( TaskCode taskCode,\r\n                        const unsigned int stackDepth,\r\n                        void * parameters,\r\n                        const unsigned int priority\r\n                      )\r\n```\r\nCreates a new task and add it to the list of tasks that are ready to run.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `taskCode` | the function to execute in its own task |\r\n| `stackDepth` | the number of variables available on the stack (4 * stackDepth bytes will be allocated on the Cortex) |\r\n| `parameters` | an argument passed to the taskCode function |\r\n| `priority` | a value from TASK_PRIORITY_LOWEST to TASK_PRIORITY_HIGHEST determining the initial priority of the task |\r\n\r\n**Returns** a handle to the created task, or NULL if an error occurred\r\n\r\n\r\n"},{"title":"taskDelay","href":"#taskDelay","content":"\n```\r\nvoid taskDelay ( const unsigned long msToDelay )\r\n```\r\nDelays the current task for a given number of milliseconds.\r\n\r\nDelaying for a period of zero will force a reschedule, where tasks of equal priority may be scheduled if available. The calling task will still be available for immediate rescheduling once the other tasks have had their turn or if nothing of equal or higher priority is available to be scheduled.\r\n\r\nThis is not the best method to have a task execute code at predefined intervals, as the delay time is measured from when the delay is requested. To delay cyclically, use [taskDelayUntil()]({{< relref \"#taskDelayUntil\" >}}).\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `msToDelay` | the number of milliseconds to wait, with 1000 milliseconds per second |\r\n\r\n\r\n"},{"title":"taskDelayUntil","href":"#taskDelayUntil","content":"\n```\r\nvoid taskDelayUntil ( unsigned long * previousWakeTime,\r\n                      const unsigned long cycleTime\r\n                    )\r\n```\r\nDelays the current task until a specified time.\r\n\r\nThe task will be unblocked at the time \\*previousWakeTime + cycleTime, and \\*previousWakeTime will be changed to reflect the time at which the task will unblock.\r\n\r\nIf the target time is in the past, no delay occurs, but a reschedule is forced, as if [taskDelay()]({{< relref \"#taskDelay\" >}}) was called with an argument of zero. If the sum of cycleTime and \\*previousWakeTime overflows or underflows, undefined behavior occurs.\r\n\r\nThis function should be used by cyclical tasks to ensure a constant execution frequency. While [taskDelay()]({{< relref \"#taskDelay\" >}}) specifies a wake time relative to the time at which the function is called, [taskDelayUntil()]({{< relref \"#taskDelayUntil\" >}}) specifies the absolute future time at which it wishes to unblock. Calling [taskDelayUntil()]({{< relref \"#taskDelayUntil\" >}}) with the same cycleTime parameter value in a loop, with previousWakeTime referring to a local variable initialized to [millis()]({{< relref \"#millis\" >}}), will cause the loop to execute with a fixed period.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `previousWakeTime` | a pointer to the location storing the last unblock time, obtained by using the \"&\" operator on a variable (e.g. \"taskDelayUntil(&now, 50);\")\r\n| `cycleTime` | the number of milliseconds to wait, with 1000 milliseconds per second |\r\n\r\n\r\n"},{"title":"taskDelete","href":"#taskDelete","content":"\n```\r\nvoid taskDelete ( TaskHandle taskToDelete )\r\n```\r\nKills and removes the specified task from the kernel task list.\r\n\r\nDeleting the last task will end the program, possibly leading to undesirable states as some outputs may remain in their last set configuration.\r\n\r\nNOTE: The idle task is responsible for freeing the kernel allocated memory from tasks that have been deleted. It is therefore important that the idle task is not starved of processing time. Memory allocated by the task code is not automatically freed, and should be freed before the task is deleted.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `taskToDelete` | the task to kill; passing NULL kills the current task |\r\n\r\n\r\n"},{"title":"taskGetCount","href":"#taskGetCount","content":"\n```\r\nunsigned int taskGetCount ( )\r\n```\r\nDetermines the number of tasks that are currently being managed.\r\n\r\nThis includes all ready, blocked and suspended tasks. A task that has been deleted but not yet freed by the idle task will also be included in the count. Tasks recently created may take one context switch to be counted.\r\n\r\n**Returns** the number of tasks that are currently running, waiting, or suspended\r\n\r\n\r\n"},{"title":"taskGetState","href":"#taskGetState","content":"\n```\r\nunsigned int taskGetState ( TaskHandle task )\r\n```\r\nRetrieves the state of the specified task.\r\n\r\nNote that the state of tasks which have died may be re-used for future tasks, causing the value returned by this function to reflect a different task than possibly intended in this case.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `task` | Handle to the task to query. Passing NULL will query the current task status (which will, by definition, be TASK_RUNNING if this call returns) |\r\n\r\n**Returns** A value reflecting the task's status, one of the constants TASK_DEAD, TASK_RUNNING, TASK_RUNNABLE, TASK_SLEEPING, or TASK_SUSPENDED\r\n\r\n\r\n"},{"title":"taskPriorityGet","href":"#taskPriorityGet","content":"\n```\r\nunsigned int taskPriorityGet ( const TaskHandle task )\r\n```\r\nObtains the priority of the specified task.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `task` | the task to check; passing NULL checks the current task |\r\n\r\n**Returns** the priority of that task from 0 to TASK_MAX_PRIORITIES\r\n\r\n\r\n"},{"title":"taskPrioritySet","href":"#taskPrioritySet","content":"\n```\r\nvoid taskPrioritySet ( TaskHandle task,\r\n                       const unsigned int newPriority\r\n                     )\r\n```\r\nSets the priority of the specified task.\r\n\r\nA context switch may occur before the function returns if the priority being set is higher than the currently executing task and the task being mutated is available to be scheduled.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `task` | the task to change; passing NULL changes the current task |\r\n| `newPriority` | a value between TASK_PRIORITY_LOWEST and TASK_PRIORITY_HIGHEST inclusive indicating the new task priority |\r\n\r\n\r\n"},{"title":"taskResume","href":"#taskResume","content":"\n```\r\nvoid taskResume ( TaskHandle taskToResume )\r\n```\r\nResumes the specified task.\r\n\r\nA task that has been suspended by one or more calls to [taskSuspend()]({{< relref \"#taskSuspend\" >}}) will be made available for scheduling again by a call to [taskResume()]({{< relref \"#taskResume\" >}}). If the task was not suspended at the time of the call to [taskResume()]({{< relref \"#taskResume\" >}}), undefined behavior occurs.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `taskToResume` | the task to change; passing NULL is not allowed as the current task cannot be suspended (it is obviously running if this function is called) |\r\n\r\n\r\n"},{"title":"taskRunLoop","href":"#taskRunLoop","content":"\n```\r\nTaskHandle taskRunLoop ( void(*)(void) fn,\r\n                         const unsigned long increment\r\n                       )\r\n```\r\nStarts a task which will periodically call the specified function.\r\n\r\nIntended for use as a quick-start skeleton for cyclic tasks with higher priority than the \"main\" tasks. The created task will have priority TASK_PRIORITY_DEFAULT + 1 with the default stack size. To customize behavior, create a task manually with the specified function.\r\n\r\nThis task will automatically terminate after one further function invocation when the robot is disabled or when the robot mode is switched.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `fn` | the function to call in this loop |\r\n| `increment` | the delay between successive calls in milliseconds; the [taskDelayUntil()]({{< relref \"#taskDelayUntil\" >}}) function is used for accurate cycle timing |\r\n\r\n**Returns** a handle to the task, or NULL if an error occurred\r\n\r\n\r\n"},{"title":"taskSuspend","href":"#taskSuspend","content":"\n```\r\nvoid taskSuspend ( TaskHandle taskToSuspend )\r\n```\r\nSuspends the specified task.\r\n\r\nWhen suspended a task will not be scheduled, regardless of whether it might be otherwise available to run.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `taskToSuspend` | the task to suspend; passing NULL suspends the current task |\r\n\r\n\r\n"},{"title":"ultrasonicGet","href":"#ultrasonicGet","content":"\n```\r\nint ultrasonicGet ( ultrasonic ult )\r\n```\r\nGets the current ultrasonic sensor value in centimeters.\r\n\r\nIf no object was found, zero is returned. If the ultrasonic sensor was never started, the return value is undefined. Round and fluffy objects can cause inaccurate values to be returned.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `ult` | the Ultrasonic object from [ultrasonicInit()]({{< relref \"#ultrasonicInit\" >}}) to read |\r\n\r\n**Returns** the distance to the nearest object in centimeters\r\n\r\n\r\n"},{"title":"ultrasonicInit","href":"#ultrasonicInit","content":"\n```\r\nUltrasonic ultrasonicInit ( unsigned char portEcho,\r\n                            unsigned char portPing\r\n                          )\r\n```\r\nInitializes an ultrasonic sensor on the specified digital ports.\r\n\r\nThe ultrasonic sensor will be polled in the background in concert with the other sensors registered using this method. NULL will be returned if either port is invalid or the ultrasonic sensor port is already in use.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `portEcho` | the port connected to the orange cable from 1-9,11-12 |\r\n| `portPing` | the port connected to the yellow cable from 1-12 |\r\n\r\n**Returns** an Ultrasonic object to be stored and used for later calls to ultrasonic functions\r\n\r\n\r\n"},{"title":"ultrasonicShutdown","href":"#ultrasonicShutdown","content":"\n```\r\nvoid ultrasonicShutdown ( Ultrasonic ult )\r\n```\r\nStops and disables the ultrasonic sensor.\r\n\r\nThe last distance it had before stopping will be retained. One more ping operation may occur before the sensor is fully disabled.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `ult` | the Ultrasonic object from [ultrasonicInit()]({{< relref \"#ultrasonicInit\" >}}) to stop |\r\n\r\n\r\n"},{"title":"usartInit","href":"#usartInit","content":"\n```\r\nvoid usartInit ( FILE * usart,\r\n                 unsigned int baud,\r\n                 unsigned int flags\r\n               )\r\n```\r\nInitialize the specified serial interface with the given connection parameters.\r\n\r\nI/O to the port is accomplished using the \"standard\" I/O functions such as [fputs()]({{< relref \"#fputs\" >}}), [fprintf()]({{< relref \"#fprintf\" >}}), and [fputc()]({{< relref \"#fputc\" >}}).\r\n\r\nRe-initializing an open port may cause loss of data in the buffers. This routine may be safely called from initializeIO() or when the scheduler is paused. If I/O is attempted on a serial port which has never been opened, the behavior will be the same as if the port had been disabled.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `usart` | the port to open, either \"uart1\" or \"uart2\" |\r\n| `baud` | the baud rate to use from 2400 to 1000000 baud |\r\n| `flags` | a bit mask combination of the SERIAL_* flags specifying parity, stop, and data bits |\r\n\r\n\r\n"},{"title":"usartShutdown","href":"#usartShutdown","content":"\n```\r\nvoid usartShutdown ( FILE * usart )\r\n```\r\nDisables the specified USART interface.\r\n\r\nAny data in the transmit and receive buffers will be lost. Attempts to read from the port when it is disabled will deadlock, and attempts to write to it may deadlock depending on the state of the buffer.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `usart` | the port to close, either \"uart1\" or \"uart2\" |\r\n\r\n\r\n"},{"title":"wait","href":"#wait","content":"\n```\r\nvoid wait ( const unsigned long time )\r\n```\r\nAlias of [taskDelay()]({{< relref \"#taskDelay\" >}}) intended to help EasyC users.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `time` | the duration of the delay in milliseconds (1 000 milliseconds per second) |\r\n\r\n\r\n"},{"title":"waitUntil","href":"#waitUntil","content":"\n```\r\nvoid waitUntil ( unsigned long * previousWakeTime,\r\n                 const unsigned long time\r\n               )\r\n```\r\nAlias of [taskDelayUntil()]({{< relref \"#taskDelayUntil\" >}}) intended to help EasyC users.\r\n\r\n| Parameters | |\r\n| ---:|:--- |\r\n| `previousWakeTime` | a pointer to the last wakeup time |\r\n| `time` | the duration of the delay in milliseconds (1 000 milliseconds per second) |\r\n\r\n\r\n\r\n"},{"title":"#define ACCEL_X  5","href":"#define-accel-x-5","content":"\nAnalog axis for the X acceleration from the VEX joystick.\r\n\r\n\r\n"},{"title":"#define ACCEL_Y  6","href":"#define-accel-y-6","content":"\nAnalog axis for the Y acceleration from the VEX Joystick.\r\n\r\n"},{"title":"#define \tBOARD_NR_ADC_PINS   8","href":"#define-board-nr_adc_pins-8","content":"\nThere are 8 available analog I/O on the Cortex.\r\n\r\n"},{"title":"#define \tBOARD_NR_GPIO_PINS   27","href":"#define-board-nr_gpio_pins-27","content":"\nThere are 27 available I/O on the Cortex that can be used for digital communication.\r\n\r\nThis excludes the crystal ports but includes the Communications, Speaker, and Analog ports.\r\n\r\nThe motor ports are not on the Cortex and are thus excluded from this count. Pin 0 is the Speaker port, pins 1-12 are the standard Digital I/O, 13-20 are the Analog I/O, 21+22 are UART1, 23+24 are UART2, and 25+26 are the I2C port.\r\n\r\n"},{"title":"#define \tEOF   ((int)-1)","href":"#define-eof-((int)-1)","content":"\nEOF is a value evaluating to -1.\r\n\r\n"},{"title":"#define HIGH   1","href":"#define-high-1","content":"\nUsed for digitalWrite() to specify a logic HIGH state to output.\r\n\r\nIn reality, using any non-zero expression or \"true\" will work to set a pin to HIGH.\r\n\r\n"},{"title":"#define \tIME_ADDR_MAX   0x1F","href":"#define-ime-addr_max-0x1f","content":"\nIME addresses end at 0x1F.\r\n\r\nActually using more than 10 (address 0x1A) encoders will cause unreliable communications.\r\n\r\n"},{"title":"#define \tINPUT   0x0A","href":"#define-input-0x0a","content":"\npinMode() state for digital input, with pullup.\r\n\r\nThis is the default state for the 12 Digital pins. The pullup causes the input to read as \"HIGH\" when unplugged, but is fairly weak and can safely be driven by most sources. Many VEX digital sensors rely on this behavior and cannot be used with INPUT_FLOATING.\r\n\r\n"},{"title":"#define INPUT_ANALOG   0x00","href":"#define-input-analog-0x00","content":"\npinMode() state for analog inputs.\r\n\r\nThis is the default state for the 8 Analog pins and the Speaker port. This only works on pins with analog input capabilities; use anywhere else results in undefined behavior.\r\n\r\n"},{"title":"#define INPUT_FLOATING   0x04","href":"#define-input-floating-0x04","content":"\npinMode() state for digital input, without pullup.\r\n\r\nBeware of power consumption, as digital inputs left \"floating\" may switch back and forth and cause spurious interrupts.\r\n\r\n"},{"title":"#define \tINTERRUPT_EDGE_BOTH   3","href":"#define-interrupt-edge_both-3","content":"\nWhen used in ioSetInterrupt(), triggers an interrupt on both rising and falling edges (LOW to HIGH or HIGH to LOW).\r\n\r\n"},{"title":"#define \tINTERRUPT_EDGE_FALLING   2","href":"#define-interrupt-edge_falling-2","content":"\nWhen used in ioSetInterrupt(), triggers an interrupt on falling edges (HIGH to LOW).\r\n\r\n"},{"title":"#define \tINTERRUPT_EDGE_RISING   1","href":"#define-interrupt-edge_rising-1","content":"\nWhen used in ioSetInterrupt(), triggers an interrupt on rising edges (LOW to HIGH).\r\n\r\n"},{"title":"#define \tJOY_DOWN   1","href":"#define-joy-down-1","content":"\nDOWN button (valid on channels 5, 6, 7, 8)\r\n\r\n"},{"title":"#define \tJOY_LEFT   2","href":"#define-joy-left-2","content":"\nLEFT button (valid on channels 7, 8)\r\n\r\n"},{"title":"#define \tJOY_RIGHT   8","href":"#define-joy-right-8","content":"\nRIGHT button (valid on channels 7, 8)\r\n\r\n"},{"title":"#define \tJOY_UP   4","href":"#define-joy-up-4","content":"\nUP button (valid on channels 5, 6, 7, 8)\r\n\r\n"},{"title":"#define \tLCD_BTN_CENTER   2","href":"#define-lcd-btn_center-2","content":"\nCENTER button on LCD for use with lcdReadButtons()\r\n\r\n"},{"title":"#define \tLCD_BTN_LEFT   1","href":"#define-lcd-btn_left-1","content":"\nLEFT button on LCD for use with lcdReadButtons()\r\n\r\n"},{"title":"#define \tLCD_BTN_RIGHT   4","href":"#define-lcd-btn_right-4","content":"\nRIGHT button on LCD for use with lcdReadButtons()\r\n\r\n"},{"title":"#define LOW   0","href":"#define-low-0","content":"\nUsed for digitalWrite() to specify a logic LOW state to output.\r\n\r\nIn reality, using a zero expression or \"false\" will work to set a pin to LOW.\r\n\r\n"},{"title":"#define OUTPUT   0x01","href":"#define-output-0x01","content":"\npinMode() state for digital output, push-pull.\r\n\r\nThis is the mode which should be used to output a digital HIGH or LOW value from the Cortex. This mode is useful for pneumatic solenoid valves and VEX LEDs.\r\n\r\n"},{"title":"#define OUTPUT_OD   0x05","href":"#define-output-od-0x05","content":"\npinMode() state for open-drain outputs.\r\n\r\nThis is useful in a few cases for external electronics and should not be used for the VEX solenoid or LEDs.\r\n\r\n"},{"title":"#define \tSEEK_CUR   1","href":"#define-seek-cur-1","content":"\nSEEK_CUR is used in fseek() to denote an relative position in bytes from the current file location.\r\n\r\n"},{"title":"#define SEEK_END   2","href":"#define-seek-end-2","content":"\nSEEK_END is used in fseek() to denote an absolute position in bytes from the end of the file.\r\n\r\nThe offset will most likely be negative in this case.\r\n\r\n"},{"title":"#define \tSEEK_SET   0","href":"#define-seek-set-0","content":"\nSEEK_SET is used in fseek() to denote an absolute position in bytes from the start of the file.\r\n\r\n"},{"title":"#define \tSERIAL_8N1   0x0000","href":"#define-serial-8n1-0x0000","content":"\nSpecifies the default serial settings when used in usartInit()\r\n\r\n"},{"title":"#define \tSERIAL_DATABITS_8   0x0000","href":"#define-serial-databits_8-0x0000","content":"\nBit mask for usartInit() for 8 data bits (typical)\r\n\r\n"},{"title":"#define \tSERIAL_DATABITS_9   0x1000","href":"#define-serial-databits_9-0x1000","content":"\nBit mask for usartInit() for 9 data bits.\r\n\r\n"},{"title":"#define \tSERIAL_PARITY_EVEN   0x0400","href":"#define-serial-parity_even-0x0400","content":"\nBit mask for usartInit() for Even parity.\r\n\r\n"},{"title":"#define \tSERIAL_PARITY_NONE   0x0000","href":"#define-serial-parity_none-0x0000","content":"\nBit mask for usartInit() for No parity (typical)\r\n\r\n"},{"title":"#define \tSERIAL_PARITY_ODD   0x0600","href":"#define-serial-parity_odd-0x0600","content":"\nBit mask for usartInit() for Odd parity.\r\n\r\n"},{"title":"#define \tSERIAL_STOPBITS_1   0x0000","href":"#define-serial-stopbits_1-0x0000","content":"\nBit mask for usartInit() for 1 stop bit (typical)\r\n\r\n"},{"title":"#define \tSERIAL_STOPBITS_2   0x2000","href":"#define-serial-stopbits_2-0x2000","content":"\nBit mask for usartInit() for 2 stop bits.\r\n\r\n"},{"title":"#define \tstdin   ((FILE \\*)3)","href":"#define-stdin-((file-\\*)3)","content":"\nThe standard input stream uses the PC debug terminal.\r\n\r\n"},{"title":"#define \tstdout   ((FILE \\*)3)","href":"#define-stdout-((file-\\*)3)","content":"\nThe standard output stream uses the PC debug terminal.\r\n\r\n"},{"title":"#define \tTASK_DEAD   0","href":"#define-task-dead-0","content":"\nConstant returned from taskGetState() when the task is dead or nonexistant.\r\n\r\n"},{"title":"#define \tTASK_DEFAULT_STACK_SIZE   512","href":"#define-task-default_stack_size-512","content":"\nThe recommended stack size for a new task that does an average amount of work.\r\n\r\nThis stack size is used for default tasks such as autonomous().\r\n\r\nThis is probably OK for 4-5 levels of function calls and the use of printf() with several arguments. Tasks requiring deep recursion or large local buffers will need a bigger stack.\r\n\r\n\r\n"},{"title":"#define \tTASK_MAX   16","href":"#define-task-max-16","content":"\nOnly this many tasks can exist at once.\r\n\r\nAttempts to create further tasks will not succeed until tasks end or are destroyed, AND the idle task cleans them up.\r\n\r\nChanging this value will not change the limit without a kernel recompile. The idle task and VEX daemon task count against the limit. The user autonomous() or teleop() also counts against the limit, so 12 tasks usually remain for other uses.\r\n\r\n"},{"title":"#define \tTASK_MAX_PRIORITIES   6","href":"#define-task-max_priorities-6","content":"\nThe maximum number of available task priorities, which run from 0 to 5.\r\n\r\nChanging this value will not change the priority count without a kernel recompile.\r\n\r\n"},{"title":"#define TASK_MINIMAL_STACK_SIZE   64","href":"#define-task-minimal_stack_size-64","content":"\nThe minimum stack depth for a task.\r\n\r\nScheduler state is stored on the stack, so even if the task never uses the stack, at least this much space must be allocated.\r\n\r\nFunction calls and other seemingly innocent constructs may place information on the stack. Err on the side of a larger stack when possible.\r\n\r\n"},{"title":"#define TASK_PRIORITY_DEFAULT   2","href":"#define-task-priority_default-2","content":"\nThe default task priority, which should be used for most tasks.\r\n\r\nDefault tasks such as autonomous() inherit this priority.\r\n\r\n"},{"title":"#define TASK_PRIORITY_HIGHEST   (TASK_MAX_PRIORITIES - 1)","href":"#define-task-priority_highest-(task_max_priorities---1)","content":"\nThe highest priority that can be assigned to a task.\r\n\r\nUnlike the lowest priority, this priority can be safely used without hampering interrupts. Beware of deadlock.\r\n\r\n"},{"title":"#define TASK_PRIORITY_LOWEST   0","href":"#define-task-priority_lowest-0","content":"\nThe lowest priority that can be assigned to a task, which puts it on a level with the idle task.\r\n\r\nThis may cause severe performance problems and is generally not recommended.\r\n\r\n"},{"title":"#define \tTASK_RUNNABLE   2","href":"#define-task-runnable-2","content":"\nConstant returned from taskGetState() when the task is exists and is available to run, but not currently running.\r\n\r\n"},{"title":"#define \tTASK_RUNNING   1","href":"#define-task-running-1","content":"\nConstant returned from taskGetState() when the task is actively executing.\r\n\r\n"},{"title":"#define \tTASK_SLEEPING   3","href":"#define-task-sleeping-3","content":"\nConstant returned from taskGetState() when the task is delayed or blocked waiting for a semaphore, mutex, or I/O operation.\r\n\r\n"},{"title":"#define \tTASK_SUSPENDED   4","href":"#define-task-suspended-4","content":"\nConstant returned from taskGetState() when the task is suspended using taskSuspend().\r\n\r\n"},{"title":"#define \tuart1   ((FILE \\*)1)","href":"#define-uart1-((file-\\*)1)","content":"\nUART 1 on the Cortex; must be opened first using usartInit().\r\n\r\n"},{"title":"#define \tuart2   ((FILE \\*)2)","href":"#define-uart2-((file-\\*)2)","content":"\nUART 2 on the Cortex; must be opened first using usartInit().\r\n\r\n\r\n"}]